#!/usr/bin/env python

import rosbag
import rospy
import numpy as np
from PIL import Image, ImageDraw
import cv2
import glob, os
import re
from scipy.spatial.transform import Rotation as R
from datetime import datetime

near_clip = .01
far_clip = 3.5
v_res = 640
u_res = 480
focal_length = 57 * 3.14/180
dists = np.empty((v_res*u_res*4))

s_phi = np.repeat(np.reshape(np.sin((v_res/2-np.arange(v_res))*focal_length/v_res),(1,v_res)),u_res,axis=0)
c_phi = np.repeat(np.reshape(np.cos((v_res/2-np.arange(v_res))*focal_length/v_res),(1,v_res)),u_res,axis=0)
#flipped sin and cos to account for -a term
c_theta = np.repeat(np.reshape(np.sin((u_res/2-np.arange(u_res))*focal_length/u_res),(u_res,1)),v_res,axis=1)
s_theta = np.repeat(np.reshape(np.cos((u_res/2-np.arange(u_res))*focal_length/u_res),(u_res,1)),v_res,axis=1)

#parses data to get images, tf, and accelerometer data
def parse_data(bagfile):
  bag = rosbag.Bag(bagfile)

  accel = np.empty((0,4))
  tf = np.empty((0,8))
  depth_t = []

  for topic, msg, t in bag.read_messages():
    if topic == "/camera/depth/points":
      depth = np.reshape(np.array(msg.data),(480,640))
      depth = np.ones((480,640)) - depth
      depth *= 255
      depth = depth.astype(np.uint8)
      depth = np.flip(depth, axis=0)
      im = Image.fromarray(depth)
      d = ImageDraw.Draw(im)
      #d.point([0,0,0,1,1,0,1,1,2,0,2,1,2,2,1,2,0,2],fill='red')
      #d.point([-1,-1,-2,-1,-2,-2,-1,-2],fill='red')
      im.save("depth_{}.png".format(t.to_sec()),"PNG")
      depth_t.append(t.to_sec())
    elif topic == "/accelerationVec":
      accel = np.vstack((accel,np.array([msg.x, msg.y, msg.x, t.to_sec()])))
    elif topic == "/tf":
      if msg.transforms[0].child_frame_id == 'ackerman':
        t_x = msg.transforms[0].transform.translation.x
        t_y = msg.transforms[0].transform.translation.y
        t_z = msg.transforms[0].transform.translation.z
        r_w = msg.transforms[0].transform.rotation.w
        r_x = msg.transforms[0].transform.rotation.x
        r_y = msg.transforms[0].transform.rotation.y
        r_z = msg.transforms[0].transform.rotation.z
        tf = np.vstack((tf,np.array([t_x,t_y,t_z,r_w,r_x,r_y,r_z,t.to_sec()])))
  
  depth_t.sort()
  accel = np.sort(accel)
  tf = np.sort(tf)
  
  return depth_t, accel, tf

#correlates images with tf values, and x,y locations with accelerometer values
def correlate_msgs(depth_t, accel, tf):
  t = 1
  d_tf = {}
  a_tf = np.empty((0,10))
  for d in depth_t:
    while t < tf.shape[0]-1 and tf[t,-1] < d:
      t += 1
      
    if abs(tf[t,-1]-d) < abs(tf[t-1,-1]-d):
      d_tf[round(d,2)] = tf[t]
    else:
      d_tf[round(d,2)] = tf[t-1]
  t = 1
  for a in accel:
    while t < tf.shape[0]-1 and tf[t,-1] < a[-1]:
      t += 1
    if abs(tf[t,-1]-a[-1]) < abs(tf[t-1,-1]-a[-1]):
      a_tf = np.vstack((a_tf,np.append(tf[t,:-1],a[:-1])))
    else:
      a_tf = np.vstack((a_tf,np.append(tf[t-1,:-1],a[:-1])))
  
  return d_tf, a_tf
  
#returns index values for the terrain grids given an x,y,max size,grid unit size, and grid center
def index_values(x,y,t_size, g_size, center=(0,0)):
  cell_n = int(t_size//g_size)
  i = x/g_size+cell_n/2-center[0]/g_size
  j = y/g_size+cell_n/2-center[1]/g_size
  i = np.rint(i)
  i = i.astype(np.int)
  j = np.rint(j)
  j = j.astype(np.int)
  return i,j
  
# turns the tf values into a grid for ease of searching 
def tf_to_grid(a_tf, t_size, g_size, center=(0,0)):
  cell_n = int(t_size//g_size)
  
  tf_grid = np.zeros((cell_n,cell_n,),dtype=object)
  tf_index = np.empty((0,2),dtype=np.int)
  i,j = index_values(a_tf[:,0],a_tf[:,1],t_size,g_size)
  
  for c in range(len(i)):
    x = i[c]
    y = j[c]
    if tf_grid[x,y] is None:
      tf_grid[x,y] = a_tf[c,4:]
    else:
      tf_grid[x,y] = np.append(tf_grid[x,y],a_tf[c,4:])
      tf_index = np.vstack((tf_index,[x,y]))
  
  tf_index = np.unique(tf_index,axis=0)
  tf_index = list(map(tuple,tf_index))
  return tf_grid, tf_index

#correlates image pixels with global points
def global_points(depth_filename, tf):
  global near_clip
  global far_clip
  global s_phi
  global c_phi
  global s_theta
  global c_theta
  t_x = tf[0]
  t_y = tf[1]
  t_z = tf[2]
  r_w = tf[3]
  r_x = tf[4]
  r_y = tf[5]
  r_z = tf[6]
  quat = np.array([r_x, r_y, r_z, r_w])
  trans = np.array([t_x, t_y, t_z])
  depth = cv2.imread(depth_filename,0)
  depth = depth.astype(np.float32)
  depth /= 255
  xyz = np.empty((u_res,v_res,3))
  distances = (far_clip-near_clip)*(np.ones(depth.shape)-depth) + near_clip
  xyz[:,:,2] = np.multiply(distances,c_theta)
  xyz[:,:,1] = np.multiply(np.multiply(distances,s_theta),c_phi)
  xyz[:,:,0] = np.multiply(np.multiply(distances,s_theta),s_phi)
  r = R.from_quat(quat)
  for i in range(xyz.shape[0]):
    xyz[i,:,:] = r.apply(xyz[i])
  xyz = xyz + trans
  return xyz
  
#gives points that have been explored in given image
def label_image_points(points, tf_index, t_size, g_size, center=(0,0)):
  found = np.empty((0,2))
  max_ind = int(t_size//g_size)-1
  x,y = index_values(points[:,:,0],points[:,:,1],t_size,g_size,center)
  x = np.reshape(x,(-1))
  y = np.reshape(y,(-1))
  x_lt = x<max_ind
  x_gt = 0<=x
  y_lt = y<max_ind
  y_gt = 0<=y
  x_lim = np.logical_and(x_lt,x_gt)
  y_lim = np.logical_and(y_lt,y_gt)
  in_range = np.logical_and(x_lim,y_lim)
  x = x[in_range]
  y = y[in_range]
  indices = zip(x,y)
  found = set(tf_index).intersection(indices)
  found = np.array(list(map(list,found)))
  return found
  
  
def extract_data(bagFile):
  depth_t,accel,tf = parse_data(bagFile)
  d_tf, a_tf = correlate_msgs(depth_t,accel,tf)
  tf_grid, tf_index = tf_to_grid(a_tf, 10, .1)
  np.save("tf_grid.npy",tf_grid)
  for time in depth_t:
    time = round(time,2)
    now = datetime.now()
    print(now.strftime("%H:%M:%S"))
    dist = global_points("depth_{}.png".format(time),d_tf[time])
    now = datetime.now()
    print(now.strftime("%H:%M:%S"))
    x,y = index_values(dist[:,:,0],dist[:,:,1],10,.1)
    found = label_image_points(dist,tf_index,10,.1)
    now = datetime.now()
    print(now.strftime("%H:%M:%S"))
    print(1)
    np.save("found_{}.npy".format(time),found)


if __name__=='__main__':
  for d in os.listdir('.'):
    if os.path.isdir(d):
      os.chdir(d)
      print(d)
      for sd in os.listdir('.'):
        os.chdir(sd)
        curr_dir = os.listdir('.')
        print(sd)
        for f in curr_dir:
          if f.endswith('.bag'):
            extract_data(f)
            if 'archive' not in curr_dir:
              os.mkdir('archive/')
            os.rename(f,'archive/{}'.format(f))
        os.chdir('..')
      os.chdir('..')

